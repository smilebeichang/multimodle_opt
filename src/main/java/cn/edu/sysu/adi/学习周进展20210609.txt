
FIXME   这周的学习计划：
        1.保留选择和精英策略  断点查看为何导致急剧相似（基数、惩罚系数）
             // 迭代3次  出现只有三套试卷可选
             // 迭代6次  大概率十套试卷一模一样
             // 有了评估的适应度函数，下面可以根据适者生存法则将优秀者保留下来了。选择则是根据新个体的适应度进行，但同时不意味着完全以适应度高低为导向（选择top k个适应度最高的个体，容易陷入局部最优解），因为单纯选择适应度高的个体将可能导致算法快速收敛到局部最优解而非全局最优解，我们称之为早熟。作为折中，遗传算法依据原则：适应度越高，被选择的机会越高，而适应度低的，被选择的机会就低。
             // 局部最优？ 导致过早成熟了吗 34次迭代就完全一致了
             //             交叉变异没能生效,忘记赋值给全局变量了


        2.优化长度和题型的校验设计    ok
        3.比例不要写死，out 取并集    ok
        4.伪代码的编写   (.txt)


交叉和变异  crossCover(papers);mutate(papers);
修补流程:
correct(i)
{
        1.长度校验
        correctLength(i)
        {
            if (size() == 10){
                 System.out.println("交叉/变异后,size正常");
            }else{
                System.out.println("第 "+w+" 题, 交叉/变异导致size不匹配：开始进行长度修补 ");
                //将题型的数量和题型比例进行统计
                //选择题
                while(typeChoseRation<typeLower2 && setEnd.size() != 10){
                    //where type = Chose
                    String sql = " type = 'CHOSE' order by RAND() limit 1 ";
                    ArrayList<String> arrayList = jdbcUtils.selectBySql(sql);
                    //动态更新类型比例信息
                    if(!setEnd.contains(arrayList.get(0))){
                        setEnd.addAll(tmp);
                        typeChose +=1;
                        typeChoseRation  =  typeChose/10.0;
                    }
                }

                //随机选题   FIXME  可能导致数据重复？
                while(setEnd.size() != 10){
                    //  where 1=1
                    String sql = " 1=1 order by RAND() limit 1 ";
                    ArrayList<String> arrayList = jdbcUtils.selectBySql(sql);
                    HashSet<String> tmp = new HashSet<>(arrayList);
                    setEnd.addAll(tmp);
                }
            }
        }

        2.题型校验
        correctType(i)
        {
            //=========================  1.0 指标统计   ================================
                //题型数量、比例信息
                //题型flag (-1->少于,0->正常,1->大于)
                if (typeChoseRation >= 0.2 && typeChoseRation <= 0.4) {
                    tf1 = 0;
                } else if (typeChoseRation < 0.2) {
                    tf1 = -1;
                } else {
                    tf1 = 1;
                }
                String typeFlag = "(" + tf1 + "," + tf2 + "," + tf3 + "," + tf4 + ")";
                System.out.println("目前题型占比情况： typeFlag:" + typeFlag);
            //=========================  2.0 解集统计   ================================
                // out解的容器  (可能造成题型比例失衡的解集)
                        Set<String> resultMore = new HashSet<>();
                        Set<String> resultLess = new HashSet<>();
                //表明题型1比例过多，用resultMore集合接收
                if (tf1 == 1) {
                    for (String aBachItemList : batchItemList) {
                        if (aBachItemList.split(":")[1].equals(TYPE.CHOSE+"")) {
                            resultMore.add(aBachItemList);
                        }
                    }
                }
                if(tf2==-1){
                    for (String aBachItemList : batchItemList) {
                        if (!aBachItemList.split(":")[1].equals(TYPE.FILL+"")) {
                            resultLess.add(aBachItemList);
                        }
                    }
                }
            //=========================  3.0 执行修补操作   ================================
            /*
                     *  resultMore resultLess 的关系判断
                     *      1.resultLess有  resultMore有值  ①不可能存在交集 ②做两次选取
                     *      2.resultLess无  resultMore有值  则取 resultMore
                     *      3.resultMore无  resultLess有值  则取 resultLess
                     *
                     * 目标：将in解替换out解
                     * 方法：去题库中搜索，取出新解集后，循环遍历，然后重新计算是否符合要求，这样将会导致计算很冗余
                     * 要求：
                     *      1.删除/新增不影响其他类型和属性比例 （修改type，但不修改attr）
                     *      2.如果找不到，则在较优解中随机选取一个用作替补解即可

                     * 多    选取一个带有这个属性的题目,然后(move,add)   ①多一个  ②多N个 先遍历匹配(完美解)，若没有，则寻找替补解
                     * 少    选取一个不带有这个属性的题目，然后(move,add) ①少一个  ②少N个 先遍历匹配(完美解)，若没有，则寻找替补解
                     * 多&少  多少各执行一次
                     *
                     */

            //*************************  3.1 resultLess有  resultMore有值   *************************

                    //  resultLess有  resultMore 有 分别进行两次迭代    迭代过程中需实时更新比例信息
                    //  resultMore 校验其他类型不要多  resultLess 正常校验
                    if(resultMore.size()>0 && resultLess.size()>0){
                        //获取新解的集合   大量的解、这个用在寻找替补解的过程
                        sbMore.append(" type != 'COMPREHENSIVE' or ");
                        ArrayList<String> inListMore = jdbcUtils.selectBySql(sqlMore);
                        // ori解集  out解集  in解集 的关系
                        // 原始解集 - out解 + in解 = 新解(拿新解去再次校验)
                        // 循环的逻辑：外层out解，内层in解，不断的调用题型比例校验方法，如满足要求则退出，不满足则继续遍历
                        for (int i = 0; i < outListMore.size(); i++) {
                            // 校验题型的时候，尽量需满足属性要求   本身是一个矫正因子，故不能影响其他属性的信息 是根本
                            // 如果不满足，导致下层的工作量变大
                            String p1 = " and( p1 = " + outListMore.get(i).split(":")[2].split(",")[0].substring(1,2);
                            String p2 = " and p2 = " + outListMore.get(i).split(":")[2].split(",")[1];
                            String p3 = " and p3 = " + outListMore.get(i).split(":")[2].split(",")[2];
                            String p4 = " and p4 = " + outListMore.get(i).split(":")[2].split(",")[3];
                            String p5 = " and p5 = " + outListMore.get(i).split(":")[2].split(",")[3].substring(0,1) + " ) ";

                            //  获取第二次新解的集合
                            sqlMore = sqlMore + (p1 + p2 + p3 + p4 + p5);
                            ArrayList<String> inList2 = jdbcUtils.selectBySql(sqlMore);

                            //  判断是否存在第二次新解  // 寻找完美解
                            if(inList2.size()>0){
                                //  再次校验  校验题型比例是否过多
                                b = typeCheckMore(batchItemList,outListMore.get(i),inList2.get(j));

                            }else{
                                // 寻找替补解  虽会导致一定程度的属性比例轻微变化，但一定能保证比例不失衡 大概率不会跑到这个流程分支来
                                for (int j = 0; j < inListMore.size(); j++) {
                                    // 校验题型和属性比例信息
                                    b = typeCheck(batchItemList,outListMore.get(i),inListMore.get(j));

                                    if(b){
                                        // 删除out解，添加in解
                                        for (int k = 0; k < batchItemList.size(); k++) {
                                            if (batchItemList.get(k).equals(outListMore.get(i))){
                                                batchItemList.set(k,inListMore.get(j));
                                            }
                                        }
                                        // 输出
                                        System.out.println("已找到符合要求的解，现退出循环,目前的解集为："+batchItemList.toString());
                                        break;
                                    }
                                }
                            }
                        }

                    }

            //*********************  3.1.2 resultLess 修补 **************************
                    if(tf1<0){
                        sbLess.append(" type = 'CHOSE' or ");
                    }
                    //获取新解的集合   大量的解、这个用在替补解的过程
                    String sqlLess = "(" + sbLess.toString().substring(0, sbLess.toString().length() - 3) +")";
                    ArrayList<String> inListLess = jdbcUtils.selectBySql(sqlLess);

                    // ori解集  out解集  in解集 的关系
                    // 原始解集 - out解 + in解 = 新解(拿新解去再次校验)
                    // 循环的逻辑：外层out解，内层in解，不断的调用题型比例校验方法，如满足要求则退出，不满足则继续遍历
                     for (int i = 0; i < outListLess.size(); i++) {

                            // 校验题型的时候，尽量需满足属性要求   本身是一个矫正因子，故不能影响其他属性的信息 是根本
                            // 如果不满足，导致下层的工作量变大
                            String p1 = " and( p1 = " + outListLess.get(i).split(":")[2].split(",")[0].substring(1,2);
                            String p2 = " and p2 = " + outListLess.get(i).split(":")[2].split(",")[1];
                            String p3 = " and p3 = " + outListLess.get(i).split(":")[2].split(",")[2];
                            String p4 = " and p4 = " + outListLess.get(i).split(":")[2].split(",")[3];
                            String p5 = " and p5 = " + outListLess.get(i).split(":")[2].split(",")[3].substring(0,1) + " ) ";

                            //  获取第二次新解的集合
                            sqlLess = sqlLess + (p1 + p2 + p3 + p4 + p5);
                            ArrayList<String> inList2 = jdbcUtils.selectBySql(sqlLess);

                            //  判断是否存在第二次新解  寻找完美解
                            if(inList2.size()>0){
                                // 删除out解，添加in解
                                for (int k = 0; k < batchItemList.size(); k++) {
                                    if (batchItemList.get(k).equals(outListLess.get(i))){
                                        batchItemList.set(k,inList2.get(j));
                                    }
                                }
                                // 输出
                                System.out.println("已找到符合要求的解，现退出循环,目前的解集为："+batchItemList.toString());
                                break;
                            }else{
                                // 寻找替补解   替补解虽会导致一定程度的属性比例轻微变化，但一定能保证比例不失衡 大概率不会跑到这个流程分支来
                                for (int j = 0; j < inListLess.size(); j++) {
                                    // 校验题型和属性比例信息
                                    bl = typeCheck(batchItemList,outListLess.get(i),inListLess.get(j));

                                    if(bl){
                                        // 删除out解，添加in解
                                        for (int k = 0; k < batchItemList.size(); k++) {
                                            if (batchItemList.get(k).equals(outListLess.get(i))){
                                                batchItemList.set(k,inListLess.get(j));
                                            }
                                        }
                                        // 输出
                                        System.out.println("已找到符合要求的解，现退出循环,目前的解集为："+batchItemList.toString());
                                        break;
                                    }
                                }
                            }

                     }
            //*************************  3.2 resultLess有  resultMore无值   *************************
            .......
        }


        3.属性校验
        correctAttribute(i)
        {

                ArrayList<String> bachItemList = new ArrayList();
                Collections.addAll(bachItemList, paperGenetic[w]);


        //=========================  1.0 指标统计   ================================

                //ArrayList<String> 转 hashSet<String>
                HashSet<String> itemSet = new HashSet<>(bachItemList);

                String attributeFlag = getAttributeFlag(itemSet);

                int af1 = Integer.parseInt(attributeFlag.split(",")[0]);
                int af2 = Integer.parseInt(attributeFlag.split(",")[1]);
                int af3 = Integer.parseInt(attributeFlag.split(",")[2]);
                int af4 = Integer.parseInt(attributeFlag.split(",")[3]);
                int af5 = Integer.parseInt(attributeFlag.split(",")[4]);

        //=========================  2.0 解集统计   ================================

                //根据attributeFlag 获得out解的容器(可能造成比例失衡的解集) 占比失衡的情况： ①多  ②少

                //取出属性比例过多的集合的并集（TODO 需考虑以下情况: 两个单集合，各自多一个属性，其无交集   ok）
                Set<String> resultMore = getResultMore(bachItemList,af1,af2,af3,af4,af5);

                //取出属性比例不足的集合的并集
                Set<String> resultLess = getResultLess(bachItemList,af1,af2,af3,af4,af5);



        //=========================  3.0 执行修补操作   ================================

                /*
                 *  resultMore resultLess 的关系判断
                 *      1.resultLess有  resultMore有值  则取先交集.然后按权重取
                 *          ①FIXME  retainAll 是否存在空集合的情况 可以减少迭代的次数  ②可以直接按无交集进行处理
                 *      2.resultLess无  resultMore有值 则取 resultMore
                 *      3.resultLess有  resultMore无  则取 resultLess
                 *
                 * 目标：将in解替换out解
                 * 方法：去题库中搜索，取出新解集后，循环遍历，然后重新计算是否符合要求，这样将会导致计算很冗余
                 * 要求：
                 *      1.新增、删除不影响其他类型和属性比例
                 *      2.如果找不到完美解，则在较优解中随机选取一个替换解
                 *
                 *多    可以随机选取一个带有这个属性的题目,然后(move,add)   注意：控制题型
                 *      ①多一个  ②多N个 先遍历匹配(完美解)，若没有，则进行（替补解）
                 *少    可以随机选取一个不带有这个属性的题目，然后(move,add)
                 *      ①少一个  ②少N个
                 *
                 *多&少
                 */

                //*********  3.1 resultLess有  resultMore有值   *********
                if(resultMore.size()>0 && resultLess.size()>0){
                    bachItemList = correctAttributeMoreAndLess(resultMore,resultLess,jdbcUtils,bachItemList,af1,af2,af3,af4,af5);
                }


                //********  3.2 resultLess有  resultMore无值    *******
                if(resultMore.size()==0 && resultLess.size()>0){

                    bachItemList = correctAttributeLess(resultLess,jdbcUtils,bachItemList,af1,af2,af3,af4,af5);

                }


                //********  3.3 resultLess无  resultMore有值   **********
                if(resultMore.size()>0 && resultLess.size()==0){

                    bachItemList = correctAttributeMore(resultMore,jdbcUtils,bachItemList,af1,af2,af3,af4,af5);

                }

                //    arrayList 转 数组
                String[] itemArray = new String[bachItemList.size()];
                for (int i = 0; i < bachItemList.size(); i++) {
                    itemArray[i] = bachItemList.get(i);
                }

                //  list  转 hashSet
                HashSet<String> temp3 = new HashSet<>(bachItemList);
                getAttributeFlag(temp3);
                paperGenetic[w] = itemArray;


        }
}




